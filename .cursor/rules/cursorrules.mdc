---
description: 
globs: *
alwaysApply: false
---
# Cursor Rule v2.0 - Mar.5, 2025

# Core Expertise
- Specialize in TypeScript and Playwright for end-to-end testing (UI and API).

# Coding Standards
- Use POM-style classes: `pages/` (e.g., `home-page.ts`) for UI, `api/` (e.g., `products-api.ts`) for API.
- Prefer async/await syntax over promises for cleaner test code.
- Interact with UI via `components/` (e.g., `nav-bar.ts`); use `api/` for API endpoints.
- Reference constants from `utils/constants.ts` (e.g., `BASE_URL`, `API_TOKEN`) for navigation, requests, and assertions.
- Write concise, readable test cases with clear `expect` assertions.
- Add comments to existing code rather than deleting it, unless explicitly asked.
- For UI: Store locators (not raw selectors) as class attributes in `pages/` and `components/`:
  - Define each locator in the constructor as a readonly property (e.g., `this.loginButtonLocator = page.locator('#login-btn')`).
  - Use these locators directly in methods for actions and assertions (e.g., `await this.loginButtonLocator.click()`).
  - Do not store raw selectors as class attributes or in grouped objects; convert them to locators at initialization.
- For UI methods, await element visibility or readiness before actions or assertions (e.g., `await expect(this.locator).toBeVisible('Element should be visible')`), unless the action implicitly waits (e.g., `click()`).
- For API: Use `APIRequestContext` in `api/` classes; await and assert response status (e.g., `await expect(response.status()).toBe(200)`).
- Handle expectations explicitly:
  - Use Playwright’s `expect` for all assertions (e.g., `await expect(response.status()).toBe(200)` for API, `await expect(this.locator).toBeVisible()` for UI).
  - Avoid generic checks (e.g., `if` statements) in favor of specific `expect` matchers.
  - Include meaningful failure messages where helpful (e.g., `'API call should succeed'`).
  - Chain assertions only when logically related; otherwise, split for clarity.

# Documentation
- Document all classes (e.g., `ProductsApi` in `api/`, `HomePage` in `pages/`), public methods, and constants with TypeDoc comments including:
  - Purpose and usage.
  - Parameters and return types (if applicable).
  - Concise, practical examples where helpful (e.g., “See `await productsApi.getProduct('1')`”).
- Flag any undocumented code as a priority for review.

# File Reference Guidelines
- Treat `PROJECT_STRUCTURE.md` and `TEST_PLAN.md` as read-only references reflecting the current project state when no edits are requested.
- Check these files (including from provided context) before suggesting changes to align with existing structure, tests, and strategies.
- Do not modify `PROJECT_STRUCTURE.md`, `TEST_PLAN.md`, or any other documentation unless explicitly instructed (e.g., “Update TEST_PLAN.md with this test case”); if instructed, use the current contents from context or request them if unavailable.
- If a suggestion conflicts with documented reality, flag it and ask for clarification (e.g., “`mobile/` isn’t in PROJECT_STRUCTURE.md—should it be added?”).

# File Management
- When adding or modifying files without an explicit edit request, suggest updates to `PROJECT_STRUCTURE.md` as comments (e.g., `// Add: api/ - API testing classes`) but don’t edit unless asked.
- Similarly, suggest `TEST_PLAN.md` updates for new test cases or strategy shifts as comments, awaiting approval, unless explicitly told to update the files directly.

# Notes
- If output seems misaligned with intent, clarify the request rather than assuming rule violations.
- Adapt folder references (e.g., `pages/`, `api/`) to match current structure if it evolves, per `PROJECT_STRUCTURE.md`.
- Optional: Run `npm run check-docs` (if implemented) to verify TypeDoc compliance.